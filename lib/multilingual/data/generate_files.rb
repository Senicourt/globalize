#!/usr/local/bin/ruby

# This script will generate language files and conversion tables
# for Multilingual Rails from .dat files in this directory


ML_ROOT = File.expand_path(File.dirname(__FILE__) + '/../')

header = <<EOH
# This file is automatically generated! Do not change!
# Change the .dat-files in #{ML_ROOT}/
# and rerun generate_files.rb instead.

EOH



# Generate iso3166 conversion tables
num_to_a2 = File.open("#{ML_ROOT}/tables/iso3166_num_to_a2.rb","w")
num_to_a3 = File.open("#{ML_ROOT}/tables/iso3166_num_to_a3.rb","w")
a2_to_num = File.open("#{ML_ROOT}/tables/iso3166_a2_to_num.rb","w")
a2_to_a3  = File.open("#{ML_ROOT}/tables/iso3166_a2_to_a3.rb", "w")
a3_to_num = File.open("#{ML_ROOT}/tables/iso3166_a3_to_num.rb","w")
a3_to_a2  = File.open("#{ML_ROOT}/tables/iso3166_a3_to_a2.rb", "w")
[num_to_a2, num_to_a3, a2_to_num, a2_to_a3, a3_to_num, a3_to_a2].each do |f|
  f.write header + "@@tables[:#{File.basename(f.path, '.rb')}] = {\n"
end
num2a2 = {} ; num2a3 = {}

File.read("#{ML_ROOT}/data/iso3166-conversions.dat").split(/$/).each do |line|
  next if line =~ /^#/ or line.strip.empty?
  num,a2,a3 = line.split('|').collect{|s| s.strip}
  num = num.to_i

  num_to_a2.write "  %3d => '%s',\n" % [num,a2]
  num_to_a3.write "  %3d => '%s',\n" % [num,a3]
  a2_to_num.write "  '%s' => %3d,\n" % [a2,num]
  a3_to_num.write "  '%s' => %3d,\n" % [a3,num]
  a2_to_a3.write "  '%s' => '%s',\n" % [a2,a3]
  a3_to_a2.write "  '%s' => '%s',\n" % [a3,a2]
  
  num2a2[num] = a2 ; num2a3[num] = a3
end
[num_to_a2, num_to_a3, a2_to_num, a2_to_a3, a3_to_num, a3_to_a2].each do |f|
  f.write "}\n"
  f.close
end



# Generate iso639-1 conversion tables
c1_to_c2 = {}
c2_to_c1 = {}
File.read("#{ML_ROOT}/data/iso639-1-conversions.dat").split(/$/).each do |line|
  next if line =~ /^#/ or line.strip.empty?
  c1,c2 = line.split('|').collect{|s| s.strip}
  c2 = c2.split(',').collect { |f| f.strip }

  c1_to_c2[c1] = c2.first
  c2.each { |c| c2_to_c1[c] = c1 }
end
File.open("#{ML_ROOT}/tables/iso639_1_to_2.rb","w") do |f|
  f.write header + "@@tables[:iso639_1_to_2] = {\n"
  c1_to_c2.each { |c1,c2| f.write "  '%s' => '%s',\n" % [c1,c2] }
  f.write "}\n"
end
File.open("#{ML_ROOT}/tables/iso639_2_to_1.rb","w") do |f|
  f.write header + "@@tables[:iso639_2_to_1] = {\n"
  c2_to_c1.each { |c2,c1| f.write "  '%s' => '%s',\n" % [c2,c1] }
  f.write "}\n"
end



# Create iso3166 (countries) locales
Dir.glob("#{ML_ROOT}/data/iso3166-*.dat") do |rf|
  next if rf =~ /conversions/
  locale = File.basename(rf,'.dat').gsub('iso3166-','')

  ['numeric','alpha2','alpha3'].each do |code|
    File.open("#{ML_ROOT}/locales/iso3166/#{locale}_#{code}.rb","w") do |wf|
      wf.write header
      wf.write("@countries = {\n")
      File.read(rf).split(/$/).each do |line|
        next if line =~ /^#/ or line.strip.empty?
        num,str = line.split('|',2)
        countries = str.split('|').collect { |s| s.strip }
        if countries.size > 1
          countries[1] = countries[0] if countries[1].empty?
        else
          countries[1] = countries[0]
        end
        
        case code
          when 'numeric'
            wf.write("  %3d => { :formal => \"%s\", :common => \"%s\" },\n" %
              [ num.to_i, countries[0], countries[1] ])
          when 'alpha2'
            wf.write("  '%s' => { :formal => \"%s\", :common => \"%s\" },\n" %
              [ num2a2[num.to_i], countries[0], countries[1] ])
          when 'alpha3'
            wf.write("  '%s' => { :formal => \"%s\", :common => \"%s\" },\n" %
              [ num2a3[num.to_i], countries[0], countries[1] ])
        end
      end
      wf.write("}\n")
    end
  end
end



# Create iso639-1 (languages) locales
Dir.glob("#{ML_ROOT}/data/iso639-1-*.dat") do |rf|
  next if rf =~ /conversions/
  locale = File.basename(rf,'.dat').gsub('iso639-1-','')

  File.open("#{ML_ROOT}/locales/iso639-1/#{locale}.rb","w") do |wf|
    wf.write header
    wf.write("@languages = {\n")
    File.read(rf).split(/$/).each do |line|
      next if line =~ /^#/ or line.strip.empty?
      code,str = line.split('|')
      wf.write("  '%s' => \"%s\",\n" % [code.strip.upcase,str.strip])
    end
    wf.write("}\n")
  end
end



